# Первое знакомство с Asyncio

### Зачем нам Asyncio?

При синхронной обработке мы ждем приложение, пока она обработает логику кода по очередности. Но мы можем оптимизорвать 
процесс за счет конкурентности в коде. В целом это концепция есть во многих языках, и они похожи между собой (**нп. в 
С и JavaScript**) где мы ставим элементы **async/await**. Поэтому используя **asyncio** мы можем достичь конкурентности и 
асинхронки в нашем коде.

### Что такое ограниченность производительностью ввода-вывода и ограниченность быстродействием процесса

Операции, ограниченные производительностью ввода-вывода и быстродействием процессора, обычно сосуществуют бок о бок. 
Посмотрите пример 
[example-1.py](https://github.com/Pro100-Almaz/Python-Concurrency-with-asyncio/blob/108b3e5bb7d16bfac9f8b17baa57ca7a31d5bddc/chapter_1/example-1.py), 
тут можно разделить логику кода на 2 группы и понять, какие работают быстро без ожиданий и те, которые ждут I/O процесс.

### Конкурентность, параллелизм и многозадачность

1. **Конкурентность**. К примеру, у нас есть пекарь, выпекающий два разных торта. Чтобы их испечь, нужно сначала разогреть 
духовку. Разогрев может занимать десятки минут, и пока духовка разогревается, нам не обязательно его ждать, и мы можем делать
пока другие этапы. И это и есть **Конкурентность** когда в процессе работы мы можем переключиться между задачами при ожидание 
результата процесса, не зависящее от нас.
2. **Параллелизм**. Тот же пример с пекарем, но у нас их будет 2 (или больше) и процессы будут работать параллельно не 
завися друг от друга.

<img alt="img_1.png" height="364" src="img_1.png" width="552" style="display: block; margin: auto;"/>

* Разница между конкурентностью и параллелизмом в том, что первый может работать на одном ядре процессора и применив 
многозадачность, переключатся между задачами. А для второго, нам нужна 2 ядра (или больше в зависимости от процессов), 
чтобы они были не зависимы друг от друга.

3. **Многозадачность**. Это когда во время одной задачи мы можем делать вторую, например, когда нас везет автобус на 
работу, читаем книгу. Есть 2 типа многозадачности:
   1. Вытесняющая — ОС переключает задачи с помощью квантования времени.
   2. Кооперативная — вместо того чтобы полагаться на системы мы явно определяем в коде, где можно уступить управление. 
   Также мы определяем **гранулярность** для системы, чтобы давать инструкцию для переключения. Также потребляет меньше 
   ресурсов. 

### Процессы, потоки, многопоточность и многопроцессность 

1. **Процесс** называется работающее приложение, которому выделена область памяти, недоступная другим приложениям.
2. **Поток** можно представлять себе как облегченные процессы. Кроме того, это наименьшая единица выполнения, которая может
управлять операционной системой.

<img alt="img_2.png" height="578" src="img_2.png" width="1273" style="display: block; margin: auto;"/>

Для примера понимания посмотрите код [example-2.py](https://github.com/Pro100-Almaz/Python-Concurrency-with-asyncio/blob/108b3e5bb7d16bfac9f8b17baa57ca7a31d5bddc/chapter_1/example-2.py).

<img alt="img_3.png" height="770" src="img_3.png" width="714" style="display: block; margin: auto;"/>

Также можно сделать несколько процессов [example-3.py](https://github.com/Pro100-Almaz/Python-Concurrency-with-asyncio/blob/108b3e5bb7d16bfac9f8b17baa57ca7a31d5bddc/chapter_1/example-3.py).
